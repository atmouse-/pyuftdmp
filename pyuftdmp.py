#!/usr/bin/env python2
# _*_ coding : utf-8 _*_
'''
Created on Dec 5, 2011

@author: atmouse
'''

from __future__ import print_function ## compatable with python3's print function
import sys,getopt,time
import fnmatch

class opUrlfilter:

    def rmOpHead(self):
        pass
        
    def __init__(self,ofile):
        """ 
        self.f_excl is {line:[item,UUID]} 
        {
        10: ['*/topad.js','84ED8AA0BBAA11E184118BE63775B9D5'], 
        11: ['*/tj.js','A2D5CAA0BBAA11E184129C79AC7D15B3'], 
        12: ['*/tongji.js','AB51BA40BBAA11E1841385553970C10B']
        }
        """
        self.f_excl={}
        self.dump_excl={}
        with open(ofile,'r') as fp:
            line1=fp.readline()
            pos=1
            if line1.find('\xef\xbb\xbf')==0:## deal with the utf8 bom
                line1=line1[3:]
            if "Opera Preferences version 2.1" in line1: ## parse the Opera head format
                while("[exclude]" not in fp.readline()):
                    pos+=1
                pos+=1
            elif line1=="\n" or line1=="\r\n":pass
            else:
                self.f_excl[pos]=line1.rstrip().split("=UUID:")
            for line in fp.readlines(): ##read the context,split UUID
                pos+=1
                if line.find(';')==0:continue
                if line=='\n' or line=='\r\n':continue ## ignore the blank line
                self.f_excl[pos]=line.rstrip().split("=UUID:")
                
    def lsUrllist(self):
        for line in self.f_excl.items():
            print(line)

    def reRep(self):
        """ return the repition list """
        tempList=[]
        tempRepList=[]
        for key,value in self.f_excl.items():
            if value[0] not in tempList:
                self.dump_excl[key]=value[0]
                tempList.append(value[0])
            else:
                tempRepList.append((key,value[0]))
        self.rep=1
        return tempRepList
            
    def reInc(self):
        """ return the inclusion list """
        def recp_cmp(i,x,y): # i:"pos of x"
            for n in wilds_split[i]:
                if n not in y:return 0
            return fnmatch.fnmatchcase(y,x)
        def recp_cmp2(i,k,x,z): # i:"pos of x" , k:"pos of z"
            """
            z include by x :return 1
            x include by z :return 2
            """
            for n in wilds_split[i]:
                if n not in z:
                    for m in wilds_split[k]:
                        if m not in x:return 0
                    if fnmatch.fnmatchcase(x,z):return 2
            return int(fnmatch.fnmatchcase(z,x))                        # return 1 or 0
            
        pop_list=[]
        def pop_key(key):
            if key not in pop_list:
                self.dump_excl.pop(key)
                pop_list.append(key)
                
        tempIncList=[]
        if self.rep==0:print("you must use reRep in code first");return None
        ## dump to two list,one with wild include,another didnt
        wilds={}
        nowilds={}
        #wilds={i:self.dump_excl[i] for i in self.dump_excl.keys() if ('*' in self.dump_excl[i] or '?' in self.dump_excl[i])}
        #nowilds={i:self.dump_excl[i] for i in self.dump_excl.keys() if ('*' not in self.dump_excl[i] and '?' not in self.dump_excl[i])}
        for key,item in self.dump_excl.items():
            if '*' in item:
                wilds[key]=item.replace('?','\?')
            else:
                nowilds[key]=item.replace('?','\?')
        
        wilds_split={i:wilds[i].split('*') for i in wilds}
        if wilds:
            for i in wilds:
                wilds_i=wilds[i]
                if nowilds:
                    for j in nowilds:
                        if recp_cmp(i,wilds_i,nowilds[j]):
                            tempIncList.append((i,j,wilds_i,nowilds[j]))
                            ## del the nowild inclutions
                            pop_key(j)
                for k in wilds:
                    if i<=k:continue
                    flag=recp_cmp2(i,k,wilds_i,wilds[k])
                    if flag==0:continue
                    elif flag==1:
                        tempIncList.append((i,k,wilds_i,wilds[k]))
                        ## del the wild inclutions
                        pop_key(k)
                    elif flag==2:
                        tempIncList.append((k,i,wilds[k],wilds_i))
                        pop_key(i)
        return tempIncList
        
    def dumptofile(self,tofile):
        headtext="""\
Opera Preferences version 2.1
; Do not edit this file while Opera is running
; This file is stored in UTF-8 encoding

[prefs]
prioritize excludelist=1

[include]
*

[exclude]
"""
        dump_flist=[str(self.dump_excl[i])+'\n' for i in self.dump_excl.keys()]
        fw=open(tofile,'w')
        fw.write(headtext)
        fw.writelines(dump_flist)
        fw.close()

def usage():
    print(r"Usage: COMMAND [-h] [-t] [-o DUMP2FILE] URLFILTER_FILE")
    print(r"       -h help")
    print(r"       -t output the time cost")
    print(r"       -o write to a new file")
    return 2

def main(argv):
    opts,args=getopt.getopt(sys.argv[1:],"hto:")
    input_file=""
    output_file=""
    timeflags=0
    for op,value in opts:
        if op in ("-h"):
            usage()
            sys.exit()
        if op in ("-t"):
            timeflags=1
        if op in ("-o"):
            output_file=value
    if len(args)!=1:
        usage()
        sys.exit()
    else:
        input_file=args[0]
            
    opurl=opUrlfilter(input_file)
    for n in opurl.reRep():
        print("repetition:",n)
    start_time= time.time()
    for n in opurl.reInc():
        print('inclusion:',n)
    if timeflags:print("Time elapsed:"+str(time.time()-start_time)+'s')
    
    ## write to file
    if bool(output_file):
        opurl.dumptofile(output_file)
        print("dump done!")

    
if __name__ == "__main__":
    main(sys.argv)
